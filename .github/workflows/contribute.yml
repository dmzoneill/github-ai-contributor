name: Contributor Swarm

on:
  schedule:
    - cron: '0 */3 * * *'  # Every 3 hours
  workflow_dispatch: {}     # Manual trigger

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

jobs:
  contribute:
    runs-on: ubuntu-latest
    timeout-minutes: 75

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Install ralph-loop plugin
        run: |
          claude plugin marketplace add anthropics/claude-plugins-official
          claude plugin install ralph-loop@claude-plugins-official

      - name: Set up GCP credentials
        run: |
          echo '${{ secrets.GOOGLE_APPLICATION_CREDENTIALS_JSON }}' > /tmp/gcp-credentials.json
          echo "GOOGLE_APPLICATION_CREDENTIALS=/tmp/gcp-credentials.json" >> $GITHUB_ENV

      - name: Configure git for commits
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Run contributor swarm
        env:
          CLAUDE_CODE_USE_VERTEX: ${{ secrets.CLAUDE_CODE_USE_VERTEX }}
          ANTHROPIC_VERTEX_PROJECT_ID: ${{ secrets.ANTHROPIC_VERTEX_PROJECT_ID }}
          CLOUD_ML_REGION: ${{ secrets.CLOUD_ML_REGION }}
          GITHUB_TOKEN: ${{ secrets.PROFILE_HOOK }}
        run: |
          PROMPT="You are the contributor swarm orchestrator for github-ai-contributor. You MUST use tools to do real work. Do NOT just output text.

          STEP 1: Run this command to check rate limit:
            gh api rate_limit --jq .rate.remaining
          If remaining < 500, stop immediately and report.

          STEP 2: Run this command to read the swarm state:
            cat .claude/.swarm-state.json 2>/dev/null || echo {}

          STEP 3: List all repos in target org and RANDOMIZE the order:
            gh repo list Redhat-forks --limit 200 --json name,url -q .[].name | shuf

          STEP 4: For each fork (in the randomized order), identify the upstream (parent) repo:
            gh api repos/{org}/{repo} --jq .parent.full_name

          STEP 5: Rebase all forks from their upstream repos to keep them current.

          STEP 6: Scan upstream repos for open issues. Skip issues we created ourselves.
          For each issue, assess confidence we can fix it (>= 90% threshold).
          Balance work across repos - max 3 open PRs per upstream repo.

          STEP 7: For fixable issues:
          - Create branch from upstream default branch (NOT origin): fix/issue-{number}-{short-description}
          - Implement the fix
          - Run available tests/linters
          - Commit with commitlint-valid conventional message
          - Push branch to fork
          - Create PR from fork to upstream

          STEP 8: Check our existing open PRs for:
          - Reviewer comments needing response
          - CI/pipeline failures needing fixes
          - Merge conflicts needing rebase

          STEP 9: Suggest at least 1 feature per repo (as issue on upstream) if not already done.

          STEP 10: Write results to .claude/.swarm-state.json

          STEP 11: Output a summary of all actions taken.

          IMPORTANT: You must actually run commands and do work. Do not skip steps."

          # --- Background state commit loop ---
          # Commits and pushes .swarm-state.json every 5 minutes so state
          # is preserved if the process hangs or the pipeline is terminated.
          STATE_FILE=".claude/.swarm-state.json"
          COMMIT_INTERVAL=300  # 5 minutes
          STATE_HASH=""

          (
            sleep 60  # Wait for initial work before first check
            while true; do
              sleep $COMMIT_INTERVAL

              # Only commit if file exists and is valid JSON (avoid partial writes)
              if [ -f "$STATE_FILE" ] && python3 -c "import json; json.load(open('$STATE_FILE'))" 2>/dev/null; then
                NEW_HASH=$(sha256sum "$STATE_FILE" | cut -d' ' -f1)
                if [ "$NEW_HASH" != "$STATE_HASH" ]; then
                  STATE_HASH="$NEW_HASH"
                  git add -f "$STATE_FILE" 2>/dev/null || continue
                  git diff --cached --quiet && continue
                  git commit -m "chore: periodic state checkpoint" 2>/dev/null || continue
                  git pull --rebase 2>/dev/null || true
                  git push 2>/dev/null || true
                  echo "--- [state committed and pushed] ---"
                fi
              fi
            done
          ) &
          COMMIT_PID=$!

          # --- Run claude in background ---
          touch /tmp/claude-output.log
          timeout --signal=TERM --kill-after=60 3600 \
            claude -p \
              --dangerously-skip-permissions \
              --verbose \
              --max-turns 200 \
              "$PROMPT" > /tmp/claude-output.log 2>&1 &
          CLAUDE_PID=$!

          START_TIME=$(date +%s)
          LAST_SIZE=0
          LAST_OUTPUT_TIME=$START_TIME

          # --- Monitor loop: stream output + heartbeat ---
          while kill -0 $CLAUDE_PID 2>/dev/null; do
            CURRENT_SIZE=$(stat -c%s /tmp/claude-output.log 2>/dev/null || echo 0)
            if [ "$CURRENT_SIZE" -gt "$LAST_SIZE" ]; then
              tail -c +$((LAST_SIZE + 1)) /tmp/claude-output.log 2>/dev/null
              LAST_SIZE=$CURRENT_SIZE
              LAST_OUTPUT_TIME=$(date +%s)
            fi

            NOW=$(date +%s)
            SILENT=$((NOW - LAST_OUTPUT_TIME))
            ELAPSED=$((NOW - START_TIME))

            # Print heartbeat every 30s of silence
            if [ "$SILENT" -ge 30 ]; then
              echo "--- [${ELAPSED}s elapsed, ${SILENT}s since last output, pid=$CLAUDE_PID] ---"
              LAST_OUTPUT_TIME=$NOW
            fi

            sleep 5
          done

          # Flush remaining output
          CURRENT_SIZE=$(stat -c%s /tmp/claude-output.log 2>/dev/null || echo 0)
          if [ "$CURRENT_SIZE" -gt "$LAST_SIZE" ]; then
            tail -c +$((LAST_SIZE + 1)) /tmp/claude-output.log 2>/dev/null
          fi

          wait $CLAUDE_PID 2>/dev/null || true
          ELAPSED=$(( $(date +%s) - START_TIME ))
          echo "=== Process finished after $((ELAPSED / 60))m $((ELAPSED % 60))s ==="

          # Stop the background commit loop
          kill $COMMIT_PID 2>/dev/null || true

      - name: Show summary
        if: always()
        run: |
          echo "=== Claude Output (last 200 lines) ==="
          tail -200 /tmp/claude-output.log 2>/dev/null || echo "No output log found"

      - name: Cleanup credentials
        if: always()
        run: rm -f /tmp/gcp-credentials.json

      - name: Final state commit
        if: always()
        run: |
          # Pull in case the background loop pushed commits ahead of us
          git pull --rebase 2>/dev/null || true
          git add -f .claude/.swarm-state.json 2>/dev/null || true
          git diff --cached --quiet || git commit -m "chore: final state update after contributor run"
          git push || true
